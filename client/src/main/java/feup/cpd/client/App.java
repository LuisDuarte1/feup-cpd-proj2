/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package feup.cpd.client;

import feup.cpd.game.Card;
import feup.cpd.game.Color;
import feup.cpd.game.Game;
import feup.cpd.protocol.MessageReader;
import feup.cpd.protocol.ProtocolFacade;
import feup.cpd.protocol.exceptions.InvalidMessage;
import feup.cpd.protocol.exceptions.LostConnectionException;
import feup.cpd.protocol.models.*;
import feup.cpd.protocol.models.enums.QueueType;
import feup.cpd.protocol.models.enums.StatusType;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.InetSocketAddress;
import java.nio.channels.SocketChannel;
import java.util.*;

public class App {

    public static int RECONNECT_TIMEOUT = 5;

    public static Card selectCard(List<Card> hand, Card topCard, Scanner scanner){
        int number;

        while(true){
            //VER CASO EM QUE DAO INPUTS ERRADOS
            System.out.println("\nSelect a card to play:");
            String selectedNumber = scanner.nextLine();
            try {
                number = Math.max(Integer.parseInt(selectedNumber) - 1, 0);
            } catch (NumberFormatException numberFormatException){
                System.out.println("Invalid number given... try again");
                continue;
            }
            if (number < hand.size() && hand.get(number).canPlayOn(topCard)) break;
            System.out.println("Can't play that card");
        }

        Card card = hand.get(number);
        if(card.getColor() == Color.BLACK){
            System.out.println("\nSelect a new color for the game:");
            System.out.println("\n\033[94m [1] Blue\n\033[91m [2] Red\n\033[32m [3] Green\n\033[93m [4] Yellow\033[0m");

            String selectedNumber = scanner.nextLine();

            switch(selectedNumber){
                case "1":
                    card.setNewColor(Color.BLUE);
                    break;
                case "2":
                    card.setNewColor(Color.RED);
                    break;
                case "3":
                    card.setNewColor(Color.GREEN);
                    break;
                case "4":
                    card.setNewColor(Color.YELLOW);
                    break;
            }
        }
        return card;
    }

    public static Card selectCardAuto(List<Card> hand, Card topCard){
        List<Card> possiblePlays = new ArrayList<>(hand.stream().filter(card -> card.canPlayOn(topCard)).toList());
        Collections.shuffle(possiblePlays);

        Card playedCard = possiblePlays.getFirst();
        if(playedCard.getColor() == Color.BLACK){
            playedCard.setNewColor(Color.RED);
        }
        return playedCard;
    }

    static String username = null;
    static String password = null;

    static SocketChannel clientChannel = null;

    public static void main(String[] args) throws IOException, InvalidMessage, InterruptedException {
        Scanner scanner = new Scanner(System.in);
        username = null;
        password = null;
        boolean ranked = true;
        boolean auto = false;
        if(args.length != 0){
            username = args[0];
            password = args[1];
            ranked = args[2].equals("ranked");
            auto = true;
        }

        clientChannel = SocketChannel.open(new InetSocketAddress("localhost", 4206));
        if(!auto){
            System.out.print("Enter username: ");
            username = scanner.nextLine();

            System.out.print("Enter password: ");
            password = scanner.nextLine();
        }

        QueueType queueType = ranked ? QueueType.RANKED : QueueType.NORMAL;
        if(!auto){
            System.out.println("Do you want to play ranked or normal? (ranked/normal):");
            String output = scanner.nextLine().toLowerCase(Locale.ROOT);
            queueType = output.equals("ranked") ? QueueType.RANKED : QueueType.NORMAL;
        }


        ProtocolModel protocolModel =
                null;
        try {
            protocolModel = ProtocolFacade.sendModelAndReceiveResponse(
                    clientChannel, new LoginRequest(username, password)).getFirst();
        } catch (LostConnectionException e) {
            tryReconnectToServer(e.protocolModel);
        }

        assert protocolModel != null;
        System.out.println(((Status) protocolModel).message);

        QueueToken queueToken =
                null;
        try {
            queueToken = (QueueToken) ProtocolFacade.sendModelAndReceiveResponse(
                    clientChannel, new QueueJoin(queueType)).getFirst();
        } catch (LostConnectionException e) {
            tryReconnectToServer(e.protocolModel);
        }


        clientLoop(scanner, queueToken, auto, queueType);

    }

    private static void tryReconnectToServer(ProtocolModel lostData)
            throws IOException, InterruptedException, InvalidMessage {
        while (!clientChannel.isConnected()){
            System.out.println("Trying to reconnect to server...");
            Thread.sleep(RECONNECT_TIMEOUT* 1000L);
            clientChannel = SocketChannel.open(new InetSocketAddress("localhost", 4206));
        }
        ProtocolModel protocolModel = null;
        try {
            protocolModel = ProtocolFacade.sendModelAndReceiveResponse(
                    clientChannel, new LoginRequest(username, password)).getFirst();
        } catch (LostConnectionException e) {
            tryReconnectToServer(null);
        }

        assert protocolModel != null;
        System.out.println(((Status) protocolModel).message);

        if(lostData != null){
            clientChannel.write(ProtocolFacade.createPacket(lostData));
        }

    }

    private static void clientLoop(Scanner scanner, QueueToken queueToken, boolean auto, QueueType queueType) throws IOException, InvalidMessage, InterruptedException {
        try {
            while (true) {
                var messages = ProtocolFacade.receiveFromServer(clientChannel);
                for(var message : messages){
                    switch (message) {
                        case MatchFound matchFound -> {
                            if(!auto){
                                System.out.print("Found match, do you want to accept? (Y/n):");
                                String output = scanner.nextLine().toLowerCase(Locale.ROOT);
                                boolean accepted = output.equals("y");
                                clientChannel.write(ProtocolFacade.createPacket(new AcceptMatch(
                                        accepted,
                                        queueToken.uuid,
                                        matchFound.matchID))
                                );
                            } else {
                                clientChannel.write(ProtocolFacade.createPacket(new AcceptMatch(
                                        true,
                                        queueToken.uuid,
                                        matchFound.matchID))
                                );
                            }
                        }
                        case Status status when status.code == StatusType.MATCH_STARTING -> {
                            System.out.println("Everyone accepted match... starting");
                        }
                        case Status status when status.code == StatusType.OK -> {
                            System.out.printf("Server returned: %s\n", status.message);
                        }
                        case Status status when status.code == StatusType.NOT_IN_QUEUE -> {
                            System.out.println("Removed from queue... trying again to enter");
                            if (!auto) {
                                System.out.println("Do you want to play ranked or normal? (ranked/normal):");
                                String output = scanner.nextLine().toLowerCase(Locale.ROOT);
                                queueType = output.equals("ranked") ? QueueType.RANKED : QueueType.NORMAL;
                            }

                            clientChannel.write(ProtocolFacade.createPacket(new QueueJoin(queueType)));
                        }
                        case GameState state when state.isTurn -> {
                            System.out.println("YOUR TURN!!!!");
                            if (!state.drawnCards.isEmpty()) {
                                System.out.printf("You've drawn %d cards:\n", state.drawnCards.size());
                                state.drawnCards.forEach(System.out::println);
                            }
                            System.out.println("Other player played:");
                            System.out.println(state.topCard);

                            System.out.println("Your hand:");
                            state.hand.forEach(System.out::println);

                            Card card = !auto ? selectCard(state.hand, state.topCard, scanner) : selectCardAuto(
                                    state.hand,
                                    state.topCard);
                            if(auto) Thread.sleep(1000);
                            clientChannel.write(ProtocolFacade.createPacket(new CardPlayed(state.matchUUID, card)));

                        }
                        case GameState state -> {
                            System.out.println("Other player played:");
                            System.out.println(state.topCard);

                        }
                        case Status status when status.code == StatusType.GAME_OVER -> {
                            if (!auto) {
                                System.out.println("Do you want to play ranked or normal? (ranked/normal):");
                                String output = scanner.nextLine().toLowerCase(Locale.ROOT);
                                queueType = output.equals("ranked") ? QueueType.RANKED : QueueType.NORMAL;
                            }
                            clientChannel.write(ProtocolFacade.createPacket(new QueueJoin(queueType)));
                        }
                        case QueueToken queueToken1 -> {
                            queueToken = queueToken1;
                        }
                        case null -> throw new RuntimeException("Could not receive message from server");
                        default -> throw new RuntimeException("Didn't handle packet received from server");
                    }
                }

            }
        } catch (LostConnectionException e){
            tryReconnectToServer(e.protocolModel);
            clientLoop(scanner, queueToken, auto, queueType);
        }
    }
}
