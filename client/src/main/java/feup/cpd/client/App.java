/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package feup.cpd.client;

import feup.cpd.game.Card;
import feup.cpd.game.Color;
import feup.cpd.game.Game;
import feup.cpd.protocol.MessageReader;
import feup.cpd.protocol.ProtocolFacade;
import feup.cpd.protocol.exceptions.InvalidMessage;
import feup.cpd.protocol.models.*;
import feup.cpd.protocol.models.enums.QueueType;
import feup.cpd.protocol.models.enums.StatusType;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.InetSocketAddress;
import java.nio.channels.SocketChannel;
import java.util.List;
import java.util.Locale;
import java.util.Scanner;

public class App {

    public static Card selectCard(List<Card> hand, Card topCard, Scanner scanner){
        int number;

        while(true){
            //VER CASO EM QUE DAO INPUTS ERRADOS
            System.out.println("\nSelect a card to play:");
            String selectedNumber = scanner.nextLine();
            number = Integer.parseInt(selectedNumber)-1;
            if (number<hand.size()
                    && number>0
                    && hand.get(number).canPlayOn(topCard)) break;
            System.out.println("Can't play that card");
        }

        Card card = hand.get(number);
        if(card.getColor()== Color.BLACK){
            System.out.println("\nSelect a new color for the game:");
            System.out.println("\n\033[94m [1] Blue\n\033[91m [2] Red\n\033[32m [3] Green\n\033[93m [4] Yellow\033[0m");

            String selectedNumber = scanner.nextLine();

            switch(selectedNumber){
                case "1":
                    card.setNewColor(Color.BLUE);
                    break;
                case "2":
                    card.setNewColor(Color.RED);
                    break;
                case "3":
                    card.setNewColor(Color.GREEN);
                    break;
                case "4":
                    card.setNewColor(Color.YELLOW);
                    break;
            }
        }
        return card;
    }

    public static void main(String[] args) throws IOException, InvalidMessage {
        Scanner scanner = new Scanner(System.in);
        String username = null;
        String password = null;
        if(args.length != 0){
            username = args[0];
            password = args[1];
        }

        //TODO(luisd): change this to be compatible with docker
        SocketChannel clientChannel = SocketChannel.open(new InetSocketAddress("localhost", 4206));
        if(args.length == 0){
            System.out.print("Enter username: ");
            username = scanner.nextLine();

            System.out.print("Enter password: ");
            password = scanner.nextLine();
        }

        final QueueType queueType = QueueType.NORMAL;



        ProtocolModel protocolModel =
                ProtocolFacade.sendModelAndReceiveResponse(
                        clientChannel, new LoginRequest(username, password));

        assert protocolModel != null;
        System.out.println(((Status) protocolModel).message);

        QueueToken queueToken =
                (QueueToken) ProtocolFacade.sendModelAndReceiveResponse(
                        clientChannel, new QueueJoin(queueType));

        var inGame = false;

        while (true){
            switch (ProtocolFacade.receiveFromServer(clientChannel)){
                case MatchFound matchFound -> {
                    System.out.print("Found match, do you want to accept? (Y/n):");
                    String output = scanner.nextLine().toLowerCase(Locale.ROOT);
                    boolean accepted = output.equals("y");
                    clientChannel.write(ProtocolFacade.createPacket(new AcceptMatch(
                            accepted,
                            queueToken.uuid,
                            matchFound.matchID))
                    );

                }
                case Status status when status.code == StatusType.MATCH_STARTING -> {
                    inGame = true;
                    System.out.println("Everyone accepted match... starting");
                }
                case Status status when status.code == StatusType.OK -> {
                    System.out.printf("Server returned: %s\n", status.message);
                }
                case Status status when status.code == StatusType.NOT_IN_QUEUE -> {
                    if(!inGame){
                        System.out.println("Removed from queue... trying again to enter");
                        queueToken = (QueueToken) ProtocolFacade.sendModelAndReceiveResponse(
                                clientChannel, new QueueJoin(queueType));
                    }
                }
                case GameState state when state.isTurn -> {
                    System.out.println("YOUR TURN!!!!");
                    if(!state.drawnCards.isEmpty()){
                        System.out.printf("You've drawn %d cards:\n", state.drawnCards.size());
                        state.drawnCards.forEach(System.out::println);
                    }
                    System.out.println("Other player played:");
                    System.out.println(state.topCard);

                    System.out.println("Your hand:");
                    state.hand.forEach(System.out::println);

                    Card card = selectCard(state.hand, state.topCard, scanner);
                    clientChannel.write(ProtocolFacade.createPacket(new CardPlayed(state.matchUUID, card)));

                }
                case GameState state -> {
                    System.out.println("Other player played:");
                    System.out.println(state.topCard);

                }
                case null -> throw new RuntimeException("Could not receive message from server");
                default -> throw new RuntimeException("Didn't handle packet received from server");
            }
        }

    }
}
